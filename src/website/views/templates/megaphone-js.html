<!-- Megaphone is a homebrewn reactivity framework -->
<script>
    class ComputedView {
        constructor(stateSelector, megaphone) {
            this.stateSelector = stateSelector;
            this.megaphone = megaphone;
        }

        #getStateSelectorDependencies(stateSelector) {
            const selectorBody = stateSelector.toString();
            let declaration, body;
            if (selectorBody.startsWith('function')) {
                [, declaration, body] = selectorBody.split(' ');
                body = selectorBody.substring(selectorBody.indexOf('{'));
                declaration = declaration
                    .split('(')[1]
                    .replaceAll(')', '')
                    .replaceAll('{', '')
                    .trim();
            } else {
                [declaration, body] = selectorBody.split('=>');
                declaration = declaration.replaceAll('(', '').replaceAll(')', '').trim();
            }

            const stateVariableName = declaration;
            const pattern = `${stateVariableName}\\s*\\.([a-zA-Z0-9]+)`;
            const regex = new RegExp(pattern, 'g');

            let match;
            const properties = new Set();

            while ((match = regex.exec(body)) !== null) {
                properties.add(match[1]);
            }

            return Array.from(properties);
        }

        dependencies() {
            return this.#getStateSelectorDependencies(this.stateSelector);
        }

        get() {
            const me = this;
            return this.stateSelector(
                new Proxy(me.megaphone.state, {
                    get(target, property, receiver) {
                        return target[property].get();
                    },
                })
            );
        }

        set(value) {
            throw new Error(
                'This is a computed value computed via ' +
                    this.stateSelector.toString() +
                    ' and therefore should never be set'
            );
        }

        onDeclareState(megaphone, elementProperty) {
            const { property } = elementProperty;
            const elementDependencies = this.dependencies();
            for (const dependency of elementDependencies) {
                megaphone._addDependentProperty(dependency, property);
            }
        }
    }

    class BrowserStorage {
        constructor(storageVault, key, defaultValue) {
            this.storageVault = storageVault;
            this.key = key;
            this.defaultValue = defaultValue;
        }

        get() {
            const value = this.storageVault.getItem(this.key);
            if (value === null) {
                return this.defaultValue;
            }

            try {
                return JSON.parse(value);
            } catch {
                return this.defaultValue;
            }
        }

        set(value) {
            this.storageVault.setItem(this.key, JSON.stringify(value));
        }

        onDeclareState(megaphone, elementProperty) {
            const me = this;
            const { element, property } = elementProperty;
            megaphone.watch({ property }, (newValue) => {
                me.set(newValue);
            });
        }
    }

    class UrlParamStorageAdapter {
        constructor(updateHistory = false) {
            this.updateHistory = updateHistory;
        }

        getItem(key) {
            const urlParams = new URLSearchParams(location.search);
            const storedValue = urlParams.get(key);
            if (storedValue === null) {
                return storedValue;
            }
            try {
                // If valid json, return as is, else stringify
                JSON.parse(storedValue);
                return storedValue;
            } catch {
                return JSON.stringify(storedValue);
            }
        }

        setItem(key, value) {
            let theValue = JSON.parse(value);
            if (theValue === null || theValue === undefined) {
                // do nothing
            } else if (!(theValue instanceof String)) {
                // Strings are stored "raw" while objects aren't
                theValue = value;
            }

            const url = new URL(window.location.href);
            if (theValue === undefined || theValue === null) {
                url.searchParams.delete(key);
            } else {
                url.searchParams.set(key, theValue);
            }

            if (this.updateHistory) {
                history.pushState({}, '', url.toString());
            } else {
                history.replaceState({}, '', url.toString());
            }
        }
    }

    class JsonApiValue {
        constructor(key, defaultValue, options) {
            this.key = key;
            this.defaultValue = defaultValue;
            this.options = options;
            this.mostRecentValue = defaultValue;
        }

        async init() {
            try {
                const result = await fetch(this.key);
                if (result.status === 200) {
                    this.mostRecentValue = await result.json();
                }
            } catch (err) {
                console.warn('Failed to fetch', this.key, err);
            }
        }

        set(value) {
            this.mostRecentValue = value;
        }

        get() {
            return this.options.view(this.mostRecentValue);
        }

        onDeclareState(megaphone) {
            megaphone._registerInitTask(this);
        }
    }

    class PlainValue {
        constructor(value) {
            this.value = value;
        }

        set(val) {
            this.value = val;
        }

        get() {
            return this.value;
        }

        onDeclareState() {}
    }

    class Megaphone {
        static _megaphones = [];

        constructor() {
            Megaphone._megaphones.push(this);
            this.dependents = {};
            this.watches = new Map();
            this.boundValues = new Map();
            this.state = null;
            this.stateProxy = null;
            this.initialized = false;
            this.initTasks = [];
        }

        #isBoundValueMarker(name) {
            return name.startsWith('$');
        }

        #isEventListenerMarker(name) {
            return name.startsWith('@');
        }

        #wrapAsPlainValueUnlessAlreadyDefined(value) {
            if (
                value instanceof JsonApiValue ||
                value instanceof BrowserStorage ||
                value instanceof ComputedView
            ) {
                return value;
            }
            return new PlainValue(value);
        }

        #renderAndAppend(element, valueToRender, renderFunction, index = null) {
            const rendered =
                index === null
                    ? renderFunction(valueToRender)
                    : renderFunction(valueToRender, index);
            if (rendered) {
                element.appendChild(rendered);
            }
        }

        #clearChildNodes(container) {
            let child = container.firstChild;
            while (child) {
                const nextSibling = child.nextSibling;

                if (child.nodeName.toLowerCase() !== 'template') {
                    container.removeChild(child);
                }

                child = nextSibling;
            }
        }

        #getDependents(value) {
            if (!this.dependents[value]) {
                return [];
            }
            return this.dependents[value];
        }

        #findUpdateOrder(properties) {
            const sortedList = [];
            const visited = new Set();

            const topologicalSort = (prop) => {
                if (visited.has(prop)) {
                    return;
                }

                visited.add(prop);

                const dependents = this.#getDependents(prop);

                for (const dependent of dependents) {
                    topologicalSort(dependent);
                }

                sortedList.push(prop);
            };

            for (const property of properties) {
                topologicalSort(property);
            }

            return sortedList.reverse();
        }

        #updateStateAndDependents(target, property, value) {
            this.#onUpdate(target, property, value);
            const updateOrder = this.#findUpdateOrder([property]);
            for (const dep of updateOrder) {
                const subDependentValue = this.state[dep].get();
                this.#onUpdate(target, dep, subDependentValue);
            }
        }

        #updateAllStateValues() {
            const updateOrder = this.#findUpdateOrder(Object.keys(this.state));
            for (const key of updateOrder) {
                this.#onUpdate(this.state, key, this.state[key].get());
            }
        }

        #startAllInitTasks() {
            const initTasks = [];
            for (const initTask of this.initTasks) {
                initTasks.push(initTask.init());
            }

            Promise.all(initTasks).then(() => this.#updateAllStateValues());
        }

        #onUpdate(target, property, value) {
            const boundElementValue = this.boundValues.get(property);
            if (boundElementValue) {
                for (const { element, name } of boundElementValue) {
                    element.setAttribute(name, `${value}`);
                }
            }

            const propertyWatches = this.watches.get(property);
            if (propertyWatches) {
                for (const callable of propertyWatches) {
                    callable(value);
                }
            }
        }

        #bindValuesAndEventListeners() {
            const boundValues = new Map();
            for (const element of document.querySelectorAll('*')) {
                for (const attribute of element.attributes) {
                    if (this.#isBoundValueMarker(attribute.name)) {
                        if (!boundValues.has(attribute.value)) {
                            boundValues.set(attribute.value, []);
                        }
                        boundValues.get(attribute.value).push({
                            element,
                            name: attribute.name.substring(1),
                        });
                    } else if (this.#isEventListenerMarker(attribute.name)) {
                        const eventName = attribute.name.substring(1);
                        const func = this.state[attribute.value];
                        if (func) {
                            element.addEventListener(eventName, func.get());
                        }
                    }
                }
            }
            return boundValues;
        }

        _addDependentProperty(property, dependentProperty) {
            if (!this.dependents[property]) {
                this.dependents[property] = [];
            }
            this.dependents[property].push(dependentProperty);
        }

        _registerInitTask(initTask) {
            this.initTasks.push(initTask);
        }

        watch(stateProxy, callable) {
            if (!this.watches.has(stateProxy.property)) {
                this.watches.set(stateProxy.property, [callable]);
            } else {
                this.watches.get(stateProxy.property).push(callable);
            }
        }

        declareState(state) {
            if (this.state !== null) {
                throw new Error('You may only declare state once!');
            }
            this.state = state;

            const asyncTasks = [];

            for (const property in state) {
                const element = state[property];
                state[property] = this.#wrapAsPlainValueUnlessAlreadyDefined(element);
                state[property].onDeclareState(this, { element, property });
            }

            const me = this;
            this.stateProxy = new Proxy(state, {
                set(target, property, value) {
                    const updatedValue = target[property].set(value);
                    me.#updateStateAndDependents(target, property, value);
                    return value;
                },
                get(target, property, receiver) {
                    return {
                        value: target[property].get(),
                        property,
                    };
                },
            });

            return this.stateProxy;
        }

        init() {
            if (this.initialized) {
                return;
            }
            this.initialized = true;
            this.boundValues = this.#bindValuesAndEventListeners();
            this.#updateAllStateValues();
            this.#startAllInitTasks();
        }

        view(stateSelector) {
            return new ComputedView(stateSelector, this);
        }

        sessionStorage(key, defaultValue) {
            return new BrowserStorage(window.sessionStorage, key, defaultValue);
        }

        localStorage(key, defaultValue) {
            return new BrowserStorage(window.localStorage, key, defaultValue);
        }

        urlParam(key, defaultValue) {
            return new BrowserStorage(new UrlParamStorageAdapter(), key, defaultValue);
        }

        jsonApi(key, defaultValue, options) {
            options ??= {};
            if (!options.view) {
                options.view = Megaphone.identity;
            }
            return new JsonApiValue(key, defaultValue, options);
        }

        renderEach(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                for (let idx = 0; idx < value.length; ++idx) {
                    const v = value[idx];
                    this.#renderAndAppend(element, v, renderFunc, idx);
                }
            });
        }

        render(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                this.#renderAndAppend(element, value, renderFunc);
            });
        }

        renderIf(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                if (value) {
                    this.#renderAndAppend(element, value, renderFunc);
                }
            });
        }

        webComponent(componentName, attributeGenerator) {
            return (value) => {
                const attributes = attributeGenerator(value);
                const element = document.createElement(componentName);
                for (const key of Object.keys(attributes)) {
                    element.setAttribute(key, attributes[key]);
                }
                return element;
            };
        }

        template(documentId, renderFunc) {
            return (elementToRender, idx) => {
                const templateClone = document.querySelector(documentId).content.cloneNode(true);
                if (idx === undefined || idx === null) {
                    return renderFunc(templateClone, elementToRender);
                }
                return renderFunc(templateClone, elementToRender, idx);
            };
        }

        static identity(x) {
            return x;
        }
    }
</script>

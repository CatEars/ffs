<!-- Megaphone is a homebrewn reactivity framework -->
<script>
    function getStateSelectorDependencies(stateSelector) {
        const selectorBody = stateSelector.toString();
        let declaration, body;
        if (selectorBody.startsWith('function')) {
            [, declaration, body] = selectorBody.split(' ');
            body = selectorBody.substring(selectorBody.indexOf('{'));
            declaration = declaration.split('(')[1].replaceAll(')', '').replaceAll('{', '').trim();
        } else {
            [declaration, body] = selectorBody.split('=>');
            declaration = declaration.replaceAll('(', '').replaceAll(')', '').trim();
        }

        const stateVariableName = declaration;
        const pattern = `${stateVariableName}\\s*\\.([a-zA-Z0-9]+)`;
        const regex = new RegExp(pattern, 'g');

        let match;
        const properties = new Set();

        while ((match = regex.exec(body)) !== null) {
            properties.add(match[1]);
        }

        return Array.from(properties);
    }

    class ComputedView {
        constructor(stateSelector, megaphone) {
            this.stateSelector = stateSelector;
            this.megaphone = megaphone;
        }

        dependencies() {
            return getStateSelectorDependencies(this.stateSelector);
        }

        evaluate(state) {
            const me = this;
            return this.stateSelector(
                new Proxy(state, {
                    get(target, property, receiver) {
                        const state = me.megaphone._resolveState(target[property]);
                        return state.value;
                    },
                })
            );
        }
    }

    class BrowserStorage {
        constructor(storageVault, key, defaultValue) {
            this.storageVault = storageVault;
            this.key = key;
            this.defaultValue = defaultValue;
        }

        get() {
            const value = this.storageVault.getItem(this.key);
            if (value === null) {
                return this.defaultValue;
            }

            try {
                return JSON.parse(value);
            } catch {
                return this.defaultValue;
            }
        }

        set(value) {
            this.storageVault.setItem(this.key, JSON.stringify(value));
        }
    }

    class UrlParamStorageAdapter {
        constructor(updateHistory = false) {
            this.updateHistory = updateHistory;
        }

        getItem(key) {
            const urlParams = new URLSearchParams(location.search);
            const storedValue = urlParams.get(key);
            if (storedValue === null) {
                return storedValue;
            }
            try {
                // If valid json, return as is, else stringify
                JSON.parse(storedValue);
                return storedValue;
            } catch {
                return JSON.stringify(storedValue);
            }
        }

        setItem(key, value) {
            let theValue = JSON.parse(value);
            if (theValue === null || theValue === undefined) {
                // do nothing
            } else if (!(theValue instanceof String)) {
                // Strings are stored "raw" while objects aren't
                theValue = value;
            }

            const url = new URL(window.location.href);
            if (theValue === undefined || theValue === null) {
                url.searchParams.delete(key);
            } else {
                url.searchParams.set(key, theValue);
            }

            if (this.updateHistory) {
                history.pushState({}, '', url.toString());
            } else {
                history.replaceState({}, '', url.toString());
            }
        }
    }

    class Megaphone {
        static _megaphones = [];

        constructor() {
            Megaphone._megaphones.push(this);
            this.dependents = {};
            this.watches = [];
            this.dollars = [];
            this.state = null;
            this.stateProxy = null;
            this.initialized = false;
        }

        #renderAndAppend(element, valueToRender, renderFunction, index = null) {
            const rendered =
                index === null
                    ? renderFunction(valueToRender)
                    : renderFunction(valueToRender, index);
            if (rendered) {
                element.appendChild(rendered);
            }
        }

        #clearChildNodes(container) {
            let child = container.firstChild;
            while (child) {
                const nextSibling = child.nextSibling;

                if (child.nodeName.toLowerCase() !== 'template') {
                    container.removeChild(child);
                }

                child = nextSibling;
            }
        }

        #addDependent(value, dependentValue) {
            if (!this.dependents[value]) {
                this.dependents[value] = [];
            }
            this.dependents[value].push(dependentValue);
        }

        #getDependents(value) {
            if (!this.dependents[value]) {
                return [];
            }
            return this.dependents[value];
        }

        #getWatchTree(value) {
            return topologicalSort(this.dependents, value);
        }

        #updateStateAndDependents(target, property, value) {
            this.onUpdate(target, property, value);
            const dependents = this.#getDependents(property);
            for (const dep of dependents) {
                const subDependentValue = this._resolveState(this.state[dep]);
                this.onUpdate(target, dep, subDependentValue);
            }
        }

        _resolveState(stateValue) {
            if (stateValue instanceof ComputedView) {
                return stateValue.evaluate(this.stateProxy);
            } else if (stateValue instanceof BrowserStorage) {
                return stateValue.get();
            }

            return stateValue;
        }

        watch(stateProxy, callable) {
            this.watches.push([stateProxy.property, callable]);
        }

        onUpdate(target, property, value) {
            for (const dollar of this.dollars) {
                if (dollar.value === property) {
                    const attributeName = dollar.name.substring(1);
                    dollar.element.setAttribute(attributeName, `${value}`);
                }
            }

            for (const [propertyName, callable] of this.watches) {
                if (property === propertyName) {
                    callable(value);
                }
            }
        }

        declareState(state) {
            if (this.state !== null) {
                throw new Error('You may only declare state once!');
            }
            this.state = state;

            for (const elementKey in state) {
                const element = state[elementKey];
                if (element instanceof ComputedView) {
                    const elementDependencies = element.dependencies();
                    for (const dep of elementDependencies) {
                        this.#addDependent(dep, elementKey);
                    }
                } else if (element instanceof BrowserStorage) {
                    this.watch({ property: elementKey }, (newValue) => {
                        element.set(newValue);
                    });
                }
            }

            const me = this;
            this.stateProxy = new Proxy(state, {
                set(target, property, value) {
                    const updatedValue = Reflect.set(target, property, value);
                    me.#updateStateAndDependents(target, property, value);
                    return updatedValue;
                },
                get(target, property, receiver) {
                    return {
                        value: me._resolveState(target[property]),
                        property,
                    };
                },
            });
            return this.stateProxy;
        }

        init() {
            if (this.initialized) {
                return;
            }
            this.initialized = true;
            const dollars = [];
            for (const element of document.querySelectorAll('*')) {
                for (const attribute of element.attributes) {
                    if (attribute.name.startsWith('$')) {
                        dollars.push({
                            element,
                            name: attribute.name,
                            value: attribute.value,
                        });
                    } else if (attribute.name.startsWith('+')) {
                        const eventName = attribute.name.substring(1);
                        const func = this.state[attribute.value];
                        if (func) {
                            element.addEventListener(eventName, func);
                        }
                    }
                }
            }
            this.dollars = dollars;

            for (const key of Object.keys(this.state)) {
                this.#updateStateAndDependents(
                    this.state,
                    key,
                    this._resolveState(this.state[key])
                );
            }
        }

        view(stateSelector) {
            return new ComputedView(stateSelector, this);
        }

        sessionStorage(key, defaultValue) {
            return new BrowserStorage(window.sessionStorage, key, defaultValue);
        }

        localStorage(key, defaultValue) {
            return new BrowserStorage(window.localStorage, key, defaultValue);
        }

        urlParam(key, defaultValue) {
            return new BrowserStorage(new UrlParamStorageAdapter(), key, defaultValue);
        }

        renderEach(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                for (let idx = 0; idx < value.length; ++idx) {
                    const v = value[idx];
                    this.#renderAndAppend(element, v, renderFunc, idx);
                }
            });
        }

        render(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                this.#renderAndAppend(element, value, renderFunc);
            });
        }

        renderIf(state, into, renderFunc) {
            this.watch(state, (value) => {
                const element = document.querySelector(into);
                this.#clearChildNodes(element);
                if (value) {
                    this.#renderAndAppend(element, value, renderFunc);
                }
            });
        }

        webComponent(componentName, attributeGenerator) {
            return (value) => {
                const attributes = attributeGenerator(value);
                const element = document.createElement(componentName);
                for (const key of Object.keys(attributes)) {
                    element.setAttribute(key, attributes[key]);
                }
                return element;
            };
        }
    }
</script>
